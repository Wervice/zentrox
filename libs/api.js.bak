app.post(
	"/api",
	isAdminMw,

	async (req, res) => {
		// ? Handle post API
		if (req.body.r == "deleteUser") {
			// ? Deletes Zentrox user from the system
				var username = req.body.username;
				if (!username) {
					res.status(400).send();
					return;
				}
				deleteUser(username);
				res.send({
					status: "s",
				});
					} else if (req.body.r == "userList") {
			// ? Lists Zentrox users
				var userTable = "<table>";
				var userList = fs
					.readFileSync(path.join(zentroxInstallationPath, "users.txt"))
					.toString()
					.split("\n");
				i = 0;
				while (i != userList.length) {
					if (userList[i].split(": ")[2] == "admin") {
						var userStatus = "<b>Admin</b>";
					} else {
						var userStatus = `User</td><td><button style='color:red' onclick="deleteUser('${atob(
							userList[i].split(": ")[0],
						)}')">Delete</button>`;
					}
					if (userList[i].split(": ")[0] != "") {
						userTable +=
							"<tr><td>" +
							atob(userList[i].split(": ")[0]) +
							"</td><td>" +
							userStatus +
							"</td></tr>";
					}
					i++;
				}
				var userTable = userTable + "</table>";
				res.send({
					text: userTable,
				});
			
		} else if (req.body.r == "filesRender") {
			// ? List files as HTML and sends it to front end
				var filePath = req.body.path;
				if (!filePath) {
					res.status(400).send();
					return;
				}
				var filesHTML = "";
				try {
					for (fileN of fs.readdirSync(filePath)) {
						if (fileN[0] == ".") {
							if (
								req.body.showHiddenFiles == true ||
								req.body.showHiddenFiles == "on"
							) {
								try {
									if (fs.statSync(path.join(filePath, fileN)).isFile()) {
										var fileIcon = "file.png";
										var funcToUse = "downloadFile";
									} else {
										var fileIcon = "folder.png";
										var funcToUse = "navigateFolder";
									}
								} catch {
									var fileIcon = "adminfile.png";
									var funcToUse = "alert";
								}
								var filesHTML =
									filesHTML +
									`<button class='fileButtons' onclick="${funcToUse}('${fileN}')" oncontextmenu="contextMenuF('${fileN}')" title="${fileN}"><img src="${fileIcon}"><br>${fileN
										.replaceAll("<", "&lt;")
										.replaceAll(">", "&gt;")}</button>`;
							}
						} else {
							try {
								if (fs.statSync(path.join(filePath, fileN)).isFile()) {
									var fileIcon = "file.png";
									var funcToUse = "downloadFile";
								} else {
									var fileIcon = "folder.png";
									var funcToUse = "navigateFolder";
								}
							} catch {
								var fileIcon = "adminfile.png";
								var funcToUse = "alert";
							}
							var filesHTML =
								filesHTML +
								`<button class='fileButtons' onclick="${funcToUse}('${fileN}')" oncontextmenu="contextMenuF('${fileN}')" title="${fileN}">
								<img src="${fileIcon}"><br>${fileN
									.replaceAll("<", "&lt;")
									.replaceAll(">", "&gt;")}</button>`;
						}
					}
				} catch (e) {
					zlog(e, "error");
					res.send({
						message: "no_permissions",
					});
					return;
				}
				res.send({
					content: filesHTML,
				});
			
		} else if (req.body.r == "deleteFile") {
			// ? Deletes a file from the linux file system
			
			var filePath = req.body.path;
			if (!filePath) {
				res.status(400).send();
				return;
			}
			try {
					fs.rmSync(filePath, { recursive: true, force: true });
					res.send({
						status: "s",
					});
			} catch (err) {
				console.warn("Error: " + err);
				res.status(500).send("Internal server error");
			}
		} else if (req.body.r == "renameFile") {
			// ? Renamve a file from the linux file system
			
			var filePath = req.body.path;
			var newName = req.body.newName;
			if (!filePath || !newName) {
				res.status(400).send();
				return;
			}
			try {
					fs.renameSync(filePath, newName);
				res.send({
					status: "s",
				});
			} catch (err) {
				console.warn("Error: " + err);
				res.status(500).send({});
			}
		} else if (req.body.r == "packageDatabase") {
			// ? Send the entire package database to the front end
			// * Early return if not admin

						zlog("Request Package Database JSON", "info");
			if (
				!fs.existsSync(path.join(zentroxInstallationPath, "allPackages.txt"))
			) {
				zlog("Database outdated");
				var packagesString = String(new Date().getTime()) + "\n";
				var allPackages = await listPackages();
				for (line of allPackages) {
					packagesString = packagesString + "\n" + line;
				}
				fs.writeFileSync(
					path.join(zentroxInstallationPath, "allPackages.txt"),
					packagesString,
				);
			}

			// * Get applications, that feature a GUI
			var guiApplications = [];
			var allInstalledPackages = listInstalledPackages(); // ? All installed packages on the system
			allPackages = fs
				.readFileSync(path.join(zentroxInstallationPath, "allPackages.txt"))
				.toString("ascii")
				.split("\n");

			allPackages.splice(0, 1);
			var applicationInUsrShare = fs.readdirSync("/usr/share/applications/");
			var desktopFileContent,
				desktopFileContentLines,
				allOtherPackages,
				guiApplications;
			applicationInUsrShare.forEach((desktopFile) => {
				var pathForFile = path.join("/usr/share/applications/", desktopFile);
				if (fs.statSync(pathForFile).isFile()) {
					desktopFileContent = fs.readFileSync(pathForFile).toString("utf-8"); // ? Read desktop file
					desktopFileContentLines = desktopFileContent.split("\n");
					allOtherPackages = [];

					desktopFileContentLines.forEach((line) => {
						const parsedLine = line.split("=");
						if (parsedLine[0] == "Name") {
							appName = line.split("=")[1];
						} else if (parsedLine[0] == "Exec") {
							appExecName = path.basename(line.split("=")[1].split(" ")[0]);
						}
					});
					guiApplications[guiApplications.length] = [appName, appExecName]; // ? The GUI application as an array
				}
			});
			var i = 0;
			var allPackages = allPackages.forEach((e) => {
				if (!allInstalledPackages.includes(e)) {
					allOtherPackages[i] = e;
					i++;
				}
			});

			// * Send results to front end

			try {
				res.send({
					content: JSON.stringify({
						gui: guiApplications,
						any: allInstalledPackages,
						all: allOtherPackages,
					}), // * Sends GUI applications and installed packages as JSON
				});
			} catch (err) {
				zlog(err, "error");
				res.status(500).send({});
			}
		} else if (req.body.r == "packageDatabaseAutoremoves") {
			var packagesForAutoremove = listAutoRemove();
			res.send({
				packages: packagesForAutoremove,
			});
		} else if (req.body.r == "removePackage") {
			// ? Remove package from the system using apt, dnf, pacman

						var packageName = req.body.packageName;
			var rootPassword = req.body.sudoPassword;
			if (!packageName || !rootPassword) {
				res.status(400).send();
				return;
			}
			if (removePackage(packageName, rootPassword)) {
				res.send({
					status: "s",
				});
				zlog("Removed package " + packageName, "info");
			} else {
				res.status(500).send({});
				zlog("Failed to remove package " + packageName, "error");
			}
		} else if (req.body.r == "installPackage") {
			//? Install a package on the system

			
			var packageName = req.body.packageName;
			var rootPassword = req.body.sudoPassword;
			if (!packageName || !rootPassword) {
				res.status(400).send();
				return;
			}
			zlog("Install package " + req.body.packageName, "info");
			if (installPackage(packageName, rootPassword)) {
				res.send({
					status: "s",
				});
				zlog("Installed package " + packageName, "info");
			} else {
				res.status(500).send({});
				zlog("Failed to install package " + packageName, "error");
			}
		} else if (req.body.r == "updateFTPconfig") {
			// ? Change the FTP configuration on the system
			
			var enableFTP = req.body.enableFTP;
			var zentroxUserPassword = req.session.zentroxPassword;
			var enableDisable = req.body.enableDisable;
			if (
				typeof enableFTP === "undefined" ||
				typeof enableDisable == "undefined"
			) {
				res.status(400).send();
				return;
			}
			zlog("Change FTP Settings");
			if (enableFTP == false) {
				try {
					const killShell = new Shell("zentrox", "sh", zentroxUserPassword);
					if (
						readDatabase(
							path.join(zentroxInstallationPath, "config.db"),
							"ftp_may_be_killed",
						) == "1"
					) {
						var killDelay = 0;
					} else {
						var killDelay = 3000;
					}
					setTimeout(async () => {
						await killShell.write(
							`sudo kill ${readDatabase(path.join(zentroxInstallationPath, "config.db"), "ftp_pid")}\n`,
						);
						killShell.kill();
					}, killDelay);
				} catch (e) {
					zlog(e, "error");
				}

				writeDatabase(
					path.join(zentroxInstallationPath, "config.db"),
					"ftp_running",
					"0",
				);
			} else if (enableFTP == true) {
				if (
					readDatabase(
						path.join(zentroxInstallationPath, "config.db"),
						"ftp_running",
					) != "1"
				) {
					zlog("Starting FTP server");
					const ftpProcess = new Shell(
						"zentrox",
						"sh",
						zentroxUserPassword,
						(data) => {
							writeDatabase(
								path.join(zentroxInstallationPath, "config.db"),
								"ftp_running",
								"0",
							);
							writeDatabase(
								path.join(zentroxInstallationPath, "config.db"),
								"ftp_pid",
								"",
							);
							zlog(`FTP server exited with return of: \n${data}`);
						},
					);
					ftpProcess.write(
						`python3 ./libs/ftp.py ${os.userInfo().username} \n`,
					);

					writeDatabase(
						path.join(zentroxInstallationPath, "config.db"),
						"ftp_running",
						"1",
					);
				}
			}

			// Write changes to ftp.txt
			if (typeof enableDisable === "undefined") {
				var ftpUserPassword = req.body.ftpUserPassword;
				var ftpUserUsername = req.body.ftpUserUsername;
				var ftpLocalRoot = req.body.ftpLocalRoot;
				if (!ftpUserUsername || !ftpUserPassword || !ftpLocalRoot) {
					res.status(400).send();
					return;
				}
				if (ftpUserPassword.length != 0) {
					new_ftp_password = hash512(ftpUserPassword);
					writeDatabase(
						path.join(zentroxInstallationPath, "config.db"),
						"ftp_password",
						new_ftp_password,
					);
				}
				writeDatabase(
					path.join(zentroxInstallationPath, "config.db"),
					"ftp_username",
					ftpUserUsername,
				);
				writeDatabase(
					path.join(zentroxInstallationPath, "config.db"),
					"ftp_root",
					ftpLocalRoot,
				);
				writeDatabase(
					path.join(zentroxInstallationPath, "config.db"),
					"ftp_running",
					enableFTP == true ? "1" : "0",
				);
			} else {
				zlog(
					"Enable/Disable FTP was requested (dashboard toggle used)",
					"info",
				);
			}

			res.send({});
		} else if (req.body.r == "fetchFTPconfig") {
			// ? Send the current FTP information
			
			res.send({
				enabled:
					readDatabase(
						path.join(zentroxInstallationPath, "config.db"),
						"ftp_running",
					) == "1",
				ftpUserUsername: readDatabase(
					path.join(zentroxInstallationPath, "config.db"),
					"ftp_username",
				),
				ftpLocalRoot: readDatabase(
					path.join(zentroxInstallationPath, "config.db"),
					"ftp_root",
				),
			});
		} else if (req.body.r == "driveInformation") {
			// ? Send the current drive information to the frontent
			var driveName = req.body.driveName;

			const dfOutput = chpr.execSync("df -P").toString("ascii");
			const dfLines = dfOutput.trim().split("\n").slice(1); // ? Split output by lines, removing header
			const dfData = dfLines.map((line) => {
				const [filesystem, size, used, available, capacity, mounted] =
					line.split(/\s+/);
				return { filesystem, size, used, available, capacity, mounted };
			});
			res.send({
				drives: deviceInformation(driveName),
				ussage: dfData,
			});
		} else if (req.body.r == "deviceInformation") {
		
			const os_name = chpr
				.execSync("lsb_release -d", { stdio: "pipe" })
				.toString("ascii")
				.replace("Description:\t", "")
				.replace("\n", "");
			const zentrox_pid = process.pid;
			try {
				const battery_status = fs
					.readFileSync("/sys/class/power_supply/BAT0/status")
					.toString("ascii")
					.replaceAll("\n", "");
				const battery_capacity = fs
					.readFileSync("/sys/class/power_supply/BAT0/capacity")
					.toString("ascii");

				if (battery_status == "Discharging") {
					var battery_string = `Discharging (${battery_capacity}%)`;
				} else if (battery_status != "Full") {
					var battery_string = `Charging (${battery_capacity}%)`;
				} else {
					var battery_string = battery_status;
				}

				battery_string = battery_string.replaceAll("\n", "");
			} catch {
				battery_string = `No battery`;
			}
			const process_number = chpr
				.execSync("ps -e | wc -l", { stdio: "pipe" })
				.toString("ascii");
			const uptime = chpr
				.execSync("uptime -p")
				.toString("ascii")
				.replace("up ", "");
			const hostname = chpr
				.execSync("hostname")
				.toString("ascii")
				.replace("\n", "");
			try {
				var system_temperature =
					Math.round(
						Number(
							fs
								.readFileSync("/sys/class/thermal/thermal_zone0/temp")
								.toString("ascii"),
						) / 1000,
					) + "Â°C";
			} catch {
				var system_temperature = null;
			}
			res.send({
				os_name: os_name,
				power_supply: battery_string,
				zentrox_pid: zentrox_pid,
				process_number: process_number,
				hostname: hostname,
				uptime: uptime,
				temperature: system_temperature,
			});
		} else if (req.body.r == "power_off") {
			
			var zentroxUserPassword = req.session.zentroxUserPassword;
			if (!zentroxUserPassword) {
				res.status(400).send();
				return;
			}
			const shutdown_handler = new Shell(
				"zentrox",
				"sh",
				zentroxUserPassword,
				() => {},
			);
			setTimeout(() => {
				shutdown_handler.write("sudo poweroff\n");
			}, 500);
			res.send({});
		} else if (req.body.r == "vault_configure") {
			
			if (
				readDatabase(
					path.join(zentroxInstallationPath, "config.db"),
					"vault_enabled",
				) == "0" ||
				!fs.existsSync(path.join(zentroxInstallationPath, "vault.vlt"))
			) {
				var key = req.body.key;
				if (!key) {
					res.status(400).send();
					return;
				}
				var i = 0;
				while (i != 1000) {
					key = crypto.createHash("sha512").update(key).digest("hex");
					i++;
				}
				// ... create empty tarball
				fs.writeFileSync(path.join(zentroxInstallationPath, ".vault"), "Init");
				tar
					.c(
						{
							file: path.join(zentroxInstallationPath, "vault.tar"),
							cwd: zentroxInstallationPath,
						},
						[".vault"],
					)
					.then(() => {
						encryptAESGCM256(
							path.join(zentroxInstallationPath, "vault.tar"),
							key,
						);
						fs.copyFileSync(
							path.join(zentroxInstallationPath, "vault.tar"),
							path.join(zentroxInstallationPath, "vault.vlt"),
						);
						fs.unlinkSync(path.join(zentroxInstallationPath, "vault.tar"));
						fs.unlinkSync(path.join(zentroxInstallationPath, ".vault"));
						writeDatabase(
							path.join(zentroxInstallationPath, "config.db"),
							"vault_enabled",
							"1",
						);
						res.send({});
					});
			} else {
				if (typeof req.body.new_key === "undefined") {
					res.send({
						code: "no_decrypt_key",
					});
				} else {
					var oldKey = req.body.oldKey;
					var newKey = req.body.newKey;
					if (!oldKey || !newKey) {
						res.status(400).send("Bad request");
						return;
					}
					var i = 0;
					var j = 0;
					while (i != 1000) {
						oldKey = crypto.createHash("sha512").update(oldKey).digest("hex");
						i++;
					}
					while (j != 1000) {
						newKey = crypto.createHash("sha512").update(newKey).digest("hex");
						j++;
					}
					try {
						waitForVaultUnlock().then(() => {
							lockFile(vaultFilePath);
							decryptAESGCM256(
								path.join(zentroxInstallationPath, "vault.vlt"),
								oldKey,
							);
							encryptAESGCM256(
								path.join(zentroxInstallationPath, "vault.vlt"),
								newKey,
							);
							unlockFile(vaultFilePath);
							res.send({
								message: "success",
							});
						});
					} catch (e) {
						zlog(e, "error");
						res.send({
							message: "auth_failed",
						});
					}
				}
			}
		} else if (req.body.r == "vault_tree") {
						var key = req.body.key;
			if (!key) {
				res.status(400).send({});
				return;
			}
			var i = 0;
			if (!fs.existsSync(path.join(zentroxInstallationPath, "vault.vlt"))) {
				res.send({ message: "vault_not_configured" });
				return;
			}
			while (i != 1000) {
				key = crypto.createHash("sha512").update(key).digest("hex");
				i++;
			}
			waitForVaultUnlock().then(() => {
				lockFile(vaultFilePath);

				try {
					decryptAESGCM256(
						path.join(zentroxInstallationPath, "vault.vlt"),
						key,
					);
				} catch (e) {
					zlog(e, "error");
					unlockFile(vaultFilePath);
					res.send({ message: "auth_failed" });
					return;
				}

				function getEntryFilenamesSync(tarballFilename) {
					const filenames = [];
					tar.t({
						file: tarballFilename,
						onentry: (entry) => filenames.push(entry.path),
						sync: true,
					});
					return filenames;
				}

				var entries = getEntryFilenamesSync(
					path.join(zentroxInstallationPath, "vault.vlt"),
				);
				encryptAESGCM256(path.join(zentroxInstallationPath, "vault.vlt"), key);
				unlockFile(vaultFilePath);
				res.send({ message: "decrypted", fs: entries });
			});
		} else if (req.body.r == "vault_file_download") {
			
			var fpath = req.body.path;
			var key = req.body.key;
			if (!fpath || !key) {
				res.status(400).send();
				return;
			}
			if (fpath[0] == "/") {
				fpath = fpath.replace("/", "");
			}
			var i = 0;
			if (key.length === 0) {
				res.status(400).send("Bad request");
			}
			while (i != 1000) {
				key = crypto.createHash("sha512").update(key).digest("hex");
				i++;
			}

			waitForVaultUnlock().then(() => {
				lockFile(vaultFilePath);
				decryptAESGCM256(path.join(zentroxInstallationPath, "vault.vlt"), key);
				try {
					fs.mkdirSync(path.join(zentroxInstallationPath, "vault_extract"));
				} catch {}
				try {
					tar.x(
						{
							file: path.join(zentroxInstallationPath, "vault.vlt"),
							sync: true,
							cwd: path.join(zentroxInstallationPath, "vault_extract"),
						},
						[fpath],
					);
					fs.writeFileSync(
						path.join(zentroxInstallationPath, "vault_extract", fpath),
						zlib.unzipSync(
							fs.readFileSync(
								path.join(zentroxInstallationPath, "vault_extract", fpath),
							),
						),
					);
				} catch (e) {
					zlog(e);
				}
				encryptAESGCM256(path.join(zentroxInstallationPath, "vault.vlt"), key);
				unlockFile(vaultFilePath);
				var data = fs.readFileSync(
					path.join(zentroxInstallationPath, "vault_extract", fpath),
				);
				deleteFilesRecursively(
					path.join(zentroxInstallationPath, "vault_extract"),
				);
				res.writeHead(200, {
					"Content-Type": "application/binary",
					"Content-disposition": "attachment;filename=" + path.basename(fpath),
					"Content-Length": data.length,
				});
				res.end(Buffer.from(data, "binary"));
			});
		} else if (req.body.r == "delete_vault_file") {
			
			var key = req.body.key;
			var deletePath = req.body.deletePath;
			if (!key || !deletePath) {
				res.status(400).send("Bad request");
				return;
			}
			var i = 0;
			while (i != 1000) {
				key = crypto.createHash("sha512").update(key).digest("hex");
				i++;
			}
			waitForVaultUnlock().then(() => {
				lockFile(vaultFilePath);
				decryptAESGCM256(path.join(zentroxInstallationPath, "vault.vlt"), key);
				try {
					const tarFile = new TarArchive(
						path.join(zentroxInstallationPath, "vault.vlt"),
					);
					tarFile.removeEntrySync(deletePath);
				} catch (err) {
					zlog(err, "error");
				}
				encryptAESGCM256(path.join(zentroxInstallationPath, "vault.vlt"), key);
				unlockFile(vaultFilePath);
				res.send({});
			});
		} else if (req.body.r == "renameVaultFile") {
			
			var key = req.body.key;
			var oldPath = req.body.path;
			var newPath = req.body.newName;
			if (!key || !oldPath || !newPath) {
				res.status(400).send("Bad request");
				return;
			}
			var i = 0;
			while (i != 1000) {
				key = crypto.createHash("sha512").update(key).digest("hex");
				i++;
			}
			waitForVaultUnlock().then(() => {
				try {
					lockFile(vaultFilePath);
					decryptAESGCM256(
						path.join(zentroxInstallationPath, "vault.vlt"),
						key,
					);
				} catch (err) {
					zlog(err, "error");
					res.status(500).send({
						msg: "auth_failed",
					});
					return;
				}
				try {
					const tarFile = new TarArchive(
						path.join(zentroxInstallationPath, "vault.vlt"),
					);
					tarFile.renameEntrySync(oldPath, newPath);
				} catch (err) {
					zlog(err, "error");
				}
				encryptAESGCM256(path.join(zentroxInstallationPath, "vault.vlt"), key);
				unlockFile(vaultFilePath);
				res.send({});
			});
		} else if (req.body.r == "vault_backup") {
			
			data = fs.readFileSync(path.join(zentroxInstallationPath, "vault.vlt"));
			res.writeHead(200, {
				"Content-Type": "application/binary",
				"Content-disposition": "attachment;filename=" + "vault.tar",
				"Content-Length": data.length,
			});
			res.end(Buffer.from(data, "binary"));
		} else if (req.body.r == "vault_new_folder") {
			var key = req.body.key;
			var folder_name = req.body.folder_name;
			
			if (!key || !folder_name) {
				res.status(400).send();
				return;
			}

			var i = 0;
			while (i != 1000) {
				key = crypto.createHash("sha512").update(key).digest("hex");
				i++;
			}

			waitForVaultUnlock().then(() => {
				try {
					lockFile(vaultFilePath);
					decryptAESGCM256(
						path.join(zentroxInstallationPath, "vault.vlt"),
						key,
					);
				} catch (err) {
					res.status(500).send({ message: "auth_failed" });
				}

				try {
					createFolderInTarSync(
						path.join(zentroxInstallationPath, "vault.vlt"),
						folder_name,
					);
				} catch (err) {
					zlog(err, "error");
				} finally {
					encryptAESGCM256(
						path.join(zentroxInstallationPath, "vault.vlt"),
						key,
					);
					unlockFile(vaultFilePath);
				}
				res.send({});
			});
		} else if (req.body.r == "fireWallInformation") {
					var informationShell = new Shell(
				"zentrox",
				"sh",
				req.session.zentroxPassword,
				() => {},
				true,
				20000, // Prevent long outputs and holding the server
				false,
			);
			try {
				var ufwStatusReturnData = await informationShell.write("ufw status\n");
			} catch (err) {
				zlog(err, "error");
				res.status(500).send({
					msg: "ufw_timeout",
				});
				return;
			}
			var ufwStatus = ufwStatusReturnData.toString("ascii");
			const ufwStatusLines = ufwStatus.trim().split("\n");
			const rules = [];
			const ruleLines = ufwStatusLines.slice(4);
			var index = 1;
			ruleLines.forEach((line) => {
				const [to, action, from] = line.trim().split(/\s{2,}/);
				rules.push({ index, to, action, from });
				index++;
			});
			informationShell.kill(); // Clear this shell
			res.send({
				enabled: ufwStatus.split("\n")[0] == "Status: active",
				rules: rules,
			});
		} else if (req.body.r == "switchUFW") {
						var ufwState = req.body.enableUFW;
			if (typeof ufwState === "undefined") {
				return;
			}
			const ufwShell = new Shell(
				"zentrox",
				"sh",
				req.session.zentroxPassword,
				() => {},
				true,
				1000,
				true,
			);
			try {
				if (!ufwState) {
					await ufwShell.write("ufw disable\n");
				} else {
					await ufwShell.write("ufw enable\n");
				}
			} catch (err) {
				zlog(err, "error");
			}
			ufwShell.kill();
			res.send({});
		} else if (req.body.r == "deleteFireWallRule") {
		

			var ruleIndex = req.body.index;

			if (typeof ruleIndex === "undefined") {
				return;
			}

			const deleteRuleShell = new Shell(
				"zentrox",
				"sh",
				req.session.zentroxPassword,
				() => {},
				false,
				2000,
				true,
			);
			try {
				await deleteRuleShell.write("ufw delete " + ruleIndex + "\n");
			} catch (error) {
				zlog(
					"Deleting rule using UFW resulted in it throwing to Stderr. Stopped",
				);
				res.status(500).send({
					msg: error,
				});
				return;
			}
			await deleteRuleShell.write("y\n");
			deleteRuleShell.kill();
			res.send({});
		} else if (req.body.r == "newFireWallRule") {
			
			var ruleFrom = req.body.from;
			var ruleTo = req.body.to;
			var ruleAction = req.body.action;
			zlog(ruleAction);
			if (!ruleAction) {
				return;
			}
			const newRuleShell = new Shell(
				"zentrox",
				"sh",
				req.session.zentroxPassword,
				() => {},
				true,
				20000,
				true,
			);
			if (!ruleFrom) {
				ruleFrom = "any";
			}
			if (!ruleTo) {
				ruleTo = "any";
			}
			ruleFrom = ruleFrom.replaceAll(";", "");
			ruleTo = ruleTo.replaceAll(";", "");
			const ipRegex =
				/^(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}$/;
			const portRegex = /^[a-zA-Z0-9 :]*$/;
			if (!ipRegex.test(ruleFrom)) {
				res.status(500).send({
					msg: "Malformed IP",
				});
				return;
			}
			if (!portRegex.test(ruleTo)) {
				res.send({
					msg: "Malformed port",
				});
				return;
			}
			try {
				var newRuleCommandOutput = await newRuleShell.write(
					`ufw ${ruleAction} from ${ruleFrom} to any port ${ruleTo}\n`,
				);
			} catch (err) {
				newRuleShell.kill();
				res.status(500).send({
					msg: err,
				});
				return;
			}
			newRuleShell.kill();
			res.send({
				commandOutput: newRuleCommandOutput,
			});
		} else if (req.body.r == "mwOk") {
			res.send(
				"If you are not logged in, you should not have gotten a response.",
			);
		} else {
			zlog("Got unknow request");
			res.status(400).send({});
		}
	},
);

app.get("/api", isAdminMw, async (req, res) => {
	// GET API (Not restful)
	if (req.query["r"] == "cpuPercent") {
			osu.cpu.usage().then((info) => {
				res.send({
					status: "s",
					p: Number(info),
				});
			});
	} else if (req.query["r"] == "ramPercent") {
			res.send({
				status: "s",
				p: Number((os.totalmem() - os.freemem()) / os.totalmem()) * 100,
			});
	} else if (req.query["r"] == "diskPercent") {
			var stats = fs.statfsSync("/");
			var percent =
				(stats.bsize * stats.blocks - stats.bsize * stats.bfree) /
				(stats.bsize * stats.blocks);
			res.send({
				status: "s",
				p: Number(percent) * 100,
			});
	} else if (req.query["r"] == "driveList") {
			res.send({
				status: "s",
				drives: deviceList(),
			});
	} else if (req.query["r"] == "callfile") {
			res
				.set({
					"Content-Disposition": `attachment; filename=${path.basename(
						atob(req.query["file"]),
					)}`,
				})
				.sendFile(atob(req.query["file"]));
			} else {
		res.status(400).send({
			text: "No supported command",
		});
	}
});